#!/bin/bash

DEBUG=0
DIR_SCRIPT=$(dirname "${BASH_SOURCE[0]}")
PWNBOX_CONFIG="${DIR_SCRIPT}/pwnbox-config.json"

COLOR_CYAN_BOLD="\e[1;36m"
COLOR_GREEN_BOLD="\e[1;32m"
COLOR_YELLOW_BOLD="\e[1;33m"
COLOR_RED_BOLD="\e[1;31m"
COLOR_RST="\e[0m"

SIGN_PASS="\xE2\x9C\x94" # Unicode tick
SIGN_WARNING="\xE2\x9A\xA0" # Unicode warning sign
SIGN_FAIL="\xE2\x9C\x97" # Unicode cross
SIGN_INFO="*"

function print_info() {
    echo -e "${COLOR_CYAN_BOLD}[*]${COLOR_RST} $1"
}

function print_debug() {
    if [ $DEBUG == 1 ]
    then
        if [ $# == 1 ]
        then
            echo -e "${COLOR_CYAN_BOLD}[DEBUG]${COLOR_RST} $1"
        elif [ $# == 2 ]
        then
            echo -e "${COLOR_CYAN_BOLD}[DEBUG]${COLOR_RST} '${1}'@'${BASH_SOURCE[0]}': ${2}"
        fi
    fi
}

function print_success() {
    echo -e "${COLOR_GREEN_BOLD}[+]${COLOR_RST} $1"
}

function print_warning() {
    echo -e "${COLOR_YELLOW_BOLD}[!]${COLOR_RST} $1"
}

function print_error() {
    if [ $# == 1 ]
    then
        echo -e "${COLOR_RED_BOLD}[-]${COLOR_RST} $1"
    elif [ $# == 2 ]
    then
        echo -e "${COLOR_RED_BOLD}[-]${COLOR_RST} '${1}'@'${BASH_SOURCE[0]}' failed with error: ${2}"
    fi
}

print_debug "PWNBOX_CONFIG=${PWNBOX_CONFIG}"
if [ ! -f "$PWNBOX_CONFIG" ]
then
    print_error "File '${PWNBOX_CONFIG}' does not exist."
    exit
fi

# DESCRIPTION
#     Run a command, silently or not.
# ARGUMENTS
#     silent - Set to 1 to run silently, 0 otherwise
#     command - Command to run
# RETURN CODE
#     0  - Everything is fine
#     1  - Invalid number of arguments
#     2  - First argument is invalid
#     ?  - Return code of the command
function exec_command() {
    return_code=0
    if [ $# == 2 ]
    then
        if [ "$1" == "0" -o "$1" == "1" ]
        then
            print_debug "exec_command" "Running command: ${2}"
            command_output=$(eval $2 2>&1)
            command_return_code=$?
            print_debug "exec_command" "Command's return code: ${command_return_code}"
            if [ $command_return_code == 0 ]
            then
                if [ "$1" == "0" ]
                then
                    echo "$command_output"
                fi
            else
                print_error "exec_command" "The following command did not run properly: ${2}"
                echo "$command_output"
                return_code=$command_return_code
            fi
        else
            print_error "exec_command" "First argument is incorrect: ${1}"
            return_code=2
        fi
    else
        print_error "exec_command" "Invalid number of arguments: ${#}"
        return_code=1
    fi
    return $return_code
}

# ARGUMENTS
#     command - Command to execute
#     msg - Status message
function exec_command_and_print_status() {
    return_code=0
    if [ $# == 2 ]
    then
        echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} ${2}..."
        command_output=$(exec_command "0" "$1")
        return_code=$?
        if [ $return_code == 0 ]
        then
            echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} ${2}    "
        else
            echo -e "\r${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} ${2}    "
            echo "$command_output"
        fi
        if [ $DEBUG == 1 ]
        then
            echo "$command_output"
        fi
    else
        print_error "exec_command_and_print_status" "Invalid number of arguments: ${#}"
    fi
    return $return_code
}

# DESCRIPTION
#     Populates the global variables DIR_PUB and DIR_TOOLS that contain the path of the global 
#     public and tools directories.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to find public directory path value
#     2  - Failed to find tools directory path value
function prepare_env() {
    return_code=0
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    which jq >/dev/null || return 127
    
    DIR_PUB=$(echo $pwnbox_config | jq -r .directories.dir_pub)
    DIR_TOOLS=$(echo $pwnbox_config | jq -r .directories.dir_tools)
    USER_NAME=$(logname)
    USER_HOME=$(eval echo ~$USER_NAME)
    
    print_debug "prepare_env" "DIR_PUB=${DIR_PUB}"
    print_debug "prepare_env" "DIR_TOOLS=${DIR_TOOLS}"
    print_debug "prepare_env" "USER_NAME=${USER_NAME}"
    print_debug "prepare_env" "USER_HOME=${USER_HOME}"
    
    if [ $DIR_PUB == "null" ]
    then
        return_code=1
    else
        if [ $DIR_TOOLS == "null" ]
        then
            return_code=2
        fi
    fi
    return $return_code
}

# DESCRIPTION
#     Returns the target path given a category name.
# ARGUMENTS
#     category - Category for which we need to retrieve the path
# RETURN CODE
#     0  - Everything is fine
#     1  - First argument is required: category
function get_category_path() {
    return_code=0
    if [ "$1" == "" ]
    then
        print_error "get_category_path" "Argument 1 (category) is required"
        return_code=1
    else
        echo -n "${DIR_TOOLS}/${1}"
    fi
    return $return_code
}

# DESCRIPTION
#     Check whether the current user is root.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Current user is root
#     1  - Current user is not root
function check_root_impl() {
    return_code=0
    if [ $(id -u) != 0 ]
    then
        print_error "Current user is not root."
        return_code=1
    fi
    return $return_code
}

function check_root() {
    exec_command_and_print_status "check_root_impl" "Current user permissions"
    return $?
}

# DESCRIPTION
#     Check if we have access to the Internet.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to find APT sources file
#     2  - Failed to contact a URL in the sources list
function check_internet_access_impl() {
    return_code=0
    apt_sources_files="/etc/apt/sources.list"
    if [ -f "$apt_sources_files" ]
    then
        apt_sources=$(cat "$apt_sources_files")
        for s in $(echo "$apt_sources" | grep -v '^#' | grep 'deb ' | cut -d' ' -f2)
        do
            print_debug "check_internet_access_impl" "Checking URL ${s}"
            curl -s --connect-timeout 3 "$s" >/dev/null 2>&1
            if [ $? == 0 ]
            then
                print_debug "check_internet_access_impl" "Successfully curled ${s}"
            else
                print_error "check_internet_access_impl" "Failed to curl ${s}"
                return_code=2
            fi
        done
    else
        return_code=1
        print_error "check_internet_access" "File '${apt_sources_files} does not exist"
    fi
    return $return_code
}

function check_internet_access() {
    exec_command_and_print_status "check_internet_access_impl" "Internet connectivity"
    return $?
}

# DESCRIPTION
#     Wrapper
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     ?  - Return the exit status of the last executed command that failed
function update_system() {
    export DEBIAN_FRONTEND=noninteractive
    exec_command_and_print_status "apt-get update" "Update APT package information" || return $?
    exec_command_and_print_status "apt-get dist-upgrade -o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef -qq -y --allow-downgrades --allow-remove-essential --allow-change-held-packages" "Upgrade all APT packages" || return $?
    exec_command_and_print_status "apt-get autoclean -y" "Clear APT package cache" || return $?
    exec_command_and_print_status "apt-get autoremove -y" "Remove APT packages that are no long required" || return $?
    which snap >/dev/null
    if [ $? == 0 ]
    then
        exec_command_and_print_status "snap refresh" "Update snap packages"
    fi
    return 0
}

# DESCRIPTION
#     Update Nessus if installed.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     ?  - Return the exit status of the last executed command that failed  
function update_nessus () {
    dir_tools_nessus=$(get_category_path "nessus")
    print_debug "update_nessus" "Nessus diriectory: ${dir_tools_nessus}"
    if [ $? == 0 ]
    then
        if [ -d $dir_tools_nessus ]
        then
            exec_command_and_print_status "service nessusd stop" "Stop Nessus service" || return $?
            exec_command_and_print_status "$dir_tools_nessus/sbin/nessuscli update --all" "Update Nessus core and plugins" || return $?
        fi
    fi
    return 0
}

function install_apt_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    apt_packages=$(echo "$pwnbox_config" | jq -r '.packages.apt[]')
    apt_packages_arg=$(echo $apt_packages)
    export DEBIAN_FRONTEND=noninteractive
    exec_command_and_print_status "apt-get install -o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef -qq -y --allow-downgrades --allow-remove-essential --allow-change-held-packages ${apt_packages_arg}" "Install additional APT packages" || return $?
    return 0
}

function install_ruby_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    ruby_packages=$(echo "$pwnbox_config" | jq -r '.packages.ruby[]')
    ruby_packages_arg=$(echo $ruby_packages)
    exec_command_and_print_status "gem install ${ruby_packages_arg}" "Install additional ruby gems" || return $?
    return 0
}

function install_python_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    python_packages=$(echo "$pwnbox_config" | jq -r '.packages.python[]')
    python_packages_arg=$(echo $python_packages)
    exec_command_and_print_status "pip3 install ${python_packages_arg}" "Install additional python packages" || return $?
    return 0
}

function download_misc_binaries() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for bin in $(echo "$pwnbox_config" | jq -r '.binaries[] | @base64')
    do
        bin_data=$(echo $bin | base64 -d)
        name=$(echo $bin_data | jq -r '.name')
        print_debug "download_misc_binaries" "Binary name: ${name}"
        url=$(echo $bin_data | jq -r '.url')
        category=$(echo $bin_data | jq -r '.category')
        script=$(echo $bin_data | jq -r '.script')
        directory="$(get_category_path $category)/${name}-bin"
        print_debug "download_misc_binaries" "Download directory: ${directory}"
        if [ ! -d "$directory" ]
        then
            mkdir -p "$directory"
            pushd "$directory" >/dev/null
            exec_command_and_print_status "wget --quiet '${url}'" "Download binary '${name}'"
            if [ $? == 0 ]
            then
                if [ "$script" != "null" ]
                then
                    exec_command "1" "$script"
                fi
            fi
            popd >/dev/null
        fi
    done
}

function download_or_update_git_repositories() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for repo in $(echo "$pwnbox_config" | jq -r '.git_repositories[] | @base64')
    do
        repo_data=$(echo $repo | base64 -d)
        user=$(echo $repo_data | jq -r '.user')
        project=$(echo $repo_data | jq -r '.project')
        category=$(echo $repo_data | jq -r '.category')
        script=$(echo $repo_data | jq -r '.script')
        directory=$(get_category_path $category)
        if [ "$user" != "null" -a "$project" != "null" ]
        then
            url="https://github.com/${user}/${project}"
            if [ ! -d "$directory" ]
            then
                mkdir -p "$directory"
            fi
            if [ -d "$directory/${project}" ]
            then
                # The directory already exists, try to update it
                print_debug "download_or_update_git_repositories" "Target directory '${directory}/${project}' exists"
                pushd "$directory/${project}" >/dev/null
                
                if [ -d "$directory/${project}/.git" ]
                then
                    # It's a GIT repository
                    echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} GIT repository '${user}/${project}'"
                    if [ $(git fetch --dry-run 2>&1 | wc -l) -gt 0 ]
                    then
                        echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} GIT repository '${user}/${project}' needs to be updated"
                        exec_command_and_print_status "git pull --no-rebase" "Update GIT repository '${user}/${project}'"
                    else
                        echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} GIT repository '${user}/${project}'"
                    fi
                else
                    echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} The directory '${directory}/${project}' is not a GIT repository"
                fi

                popd >/dev/null
             else
                # The directory doesn't exist, clone the repository
                print_debug "download_or_update_git_repositories" "Target directory '${directory}/${project}' does not exist"
                pushd "$directory" >/dev/null
                
                exec_command_and_print_status "git clone '${url}' --depth 1" "Clone GIT repository '${user}/${project}'"
                if [ "$script" != "null" ]
                then
                    pushd "$directory/${project}" >/dev/null
                    exec_command_and_print_status "$script" "Run custom install script for repository '${user}/${project}'"
                    popd >/dev/null
                fi
                
                popd >/dev/null
            fi
        fi
    done
}

