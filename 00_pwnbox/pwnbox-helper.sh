#!/bin/bash

DEBUG=0
DIR_SCRIPT=$(dirname "${BASH_SOURCE[0]}")
PWNBOX_CONFIG="${DIR_SCRIPT}/pwnbox-config.json"

COLOR_CYAN_BOLD="\e[1;36m"
COLOR_GREEN_BOLD="\e[1;32m"
COLOR_YELLOW_BOLD="\e[1;33m"
COLOR_RED_BOLD="\e[1;31m"
COLOR_RST="\e[0m"

SIGN_PASS="\xE2\x9C\x94" # Unicode tick
SIGN_WARNING="\xE2\x9A\xA0" # Unicode warning sign
SIGN_FAIL="\xE2\x9C\x97" # Unicode cross
SIGN_INFO="*"

function print_info() {
    echo -e "${COLOR_CYAN_BOLD}[*]${COLOR_RST} $1"
}

function print_debug() {
    if [ $DEBUG == 1 ]
    then
        if [ $# == 1 ]
        then
            echo -e "${COLOR_CYAN_BOLD}[DEBUG]${COLOR_RST} $1"
        elif [ $# == 2 ]
        then
            echo -e "${COLOR_CYAN_BOLD}[DEBUG]${COLOR_RST} '${1}'@'${BASH_SOURCE[0]}': ${2}"
        fi
    fi
}

function print_success() {
    echo -e "${COLOR_GREEN_BOLD}[+]${COLOR_RST} $1"
}

function print_warning() {
    echo -e "${COLOR_YELLOW_BOLD}[!]${COLOR_RST} $1"
}

function print_error() {
    if [ $# == 1 ]
    then
        echo -e "${COLOR_RED_BOLD}[-]${COLOR_RST} $1"
    elif [ $# == 2 ]
    then
        echo -e "${COLOR_RED_BOLD}[-]${COLOR_RST} '${1}'@'${BASH_SOURCE[0]}' failed with error: ${2}"
    fi
}

print_debug "PWNBOX_CONFIG=${PWNBOX_CONFIG}"
if [ ! -f "$PWNBOX_CONFIG" ]
then
    print_error "File '${PWNBOX_CONFIG}' does not exist."
    exit
fi

# DESCRIPTION
#     Run a command, silently or not.
# ARGUMENTS
#     silent - Set to 1 to run silently, 0 otherwise
#     command - Command to run
# RETURN CODE
#     0  - Everything is fine
#     1  - Invalid number of arguments
#     2  - First argument is invalid
#     ?  - Return code of the command
function exec_command() {
    return_code=0
    if [ $# == 2 ]
    then
        if [ "$1" == "0" -o "$1" == "1" ]
        then
            print_debug "exec_command" "Running command: ${2}"
            command_output=$(eval $2 2>&1)
            command_return_code=$?
            print_debug "exec_command" "Command's return code: ${command_return_code}"
            if [ $command_return_code == 0 ]
            then
                if [ "$1" == "0" ]
                then
                    echo "$command_output"
                fi
            else
                print_error "exec_command" "The following command did not run properly: ${2}"
                echo "$command_output"
                return_code=$command_return_code
            fi
        else
            print_error "exec_command" "First argument is incorrect: ${1}"
            return_code=2
        fi
    else
        print_error "exec_command" "Invalid number of arguments: ${#}"
        return_code=1
    fi
    return $return_code
}

# ARGUMENTS
#     command - Command to execute
#     msg - Status message
function exec_command_and_print_status() {
    return_code=0
    if [ $# == 2 ]
    then
        echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} ${2}..."
        command_output=$(exec_command "0" "$1")
        return_code=$?
        if [ $return_code == 0 ]
        then
            echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} ${2}    "
        else
            echo -e "\r${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} ${2}    "
            echo "$command_output"
        fi
        if [ $DEBUG == 1 ]
        then
            echo "$command_output"
        fi
    else
        print_error "exec_command_and_print_status" "Invalid number of arguments: ${#}"
    fi
    return $return_code
}

# DESCRIPTION
#     Populates the global variables DIR_PUB and DIR_TOOLS that contain the path of the global 
#     public and tools directories.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to find public directory path value
#     2  - Failed to find tools directory path value
function prepare_env() {
    return_code=0
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    which jq >/dev/null || return 127
    
    DIR_PUB=$(echo $pwnbox_config | jq -r .directories.dir_pub)
    DIR_TOOLS=$(echo $pwnbox_config | jq -r .directories.dir_tools)
    USER_NAME=$(logname)
    USER_HOME=$(eval echo ~$USER_NAME)
    
    print_debug "prepare_env" "DIR_PUB=${DIR_PUB}"
    print_debug "prepare_env" "DIR_TOOLS=${DIR_TOOLS}"
    print_debug "prepare_env" "USER_NAME=${USER_NAME}"
    print_debug "prepare_env" "USER_HOME=${USER_HOME}"
    
    if [ $DIR_PUB == "null" ]
    then
        return_code=1
    else
        if [ $DIR_TOOLS == "null" ]
        then
            return_code=2
        fi
    fi
    return $return_code
}

# DESCRIPTION
#     Returns the target path given a category name.
# ARGUMENTS
#     category - Category for which we need to retrieve the path
# RETURN CODE
#     0  - Everything is fine
#     1  - First argument is required: category
function get_category_path() {
    return_code=0
    if [ "$1" == "" ]
    then
        print_error "get_category_path" "Argument 1 (category) is required"
        return_code=1
    else
        echo -n "${DIR_TOOLS}/${1}"
    fi
    return $return_code
}

# DESCRIPTION
#     Check whether the current user is root.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Current user is root
#     1  - Current user is not root
function check_root_impl() {
    return_code=0
    if [ $(id -u) != 0 ]
    then
        print_error "Current user is not root."
        return_code=1
    fi
    return $return_code
}

function check_root() {
    exec_command_and_print_status "check_root_impl" "Current user permissions"
    return $?
}

# DESCRIPTION
#     Check if we have access to the Internet.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to find APT sources file
#     2  - Failed to contact a URL in the sources list
function check_internet_access_impl() {
    return_code=0
    apt_sources_files="/etc/apt/sources.list"
    if [ -f "$apt_sources_files" ]
    then
        apt_sources=$(cat "$apt_sources_files")
        for s in $(echo "$apt_sources" | grep -v '^#' | grep 'deb ' | cut -d' ' -f2)
        do
            print_debug "check_internet_access_impl" "Checking URL ${s}"
            curl -s --connect-timeout 3 "$s" >/dev/null 2>&1
            if [ $? == 0 ]
            then
                print_debug "check_internet_access_impl" "Successfully curled ${s}"
            else
                print_error "check_internet_access_impl" "Failed to curl ${s}"
                return_code=2
            fi
        done
    else
        return_code=1
        print_error "check_internet_access" "File '${apt_sources_files} does not exist"
    fi
    return $return_code
}

function check_internet_access() {
    exec_command_and_print_status "check_internet_access_impl" "Internet connectivity"
    return $?
}

# DESCRIPTION
#     Wrapper
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     ?  - Return the exit status of the last executed command that failed
function update_system() {
    export DEBIAN_FRONTEND=noninteractive
    exec_command_and_print_status "apt-get update" "Update APT package information" || return $?
    exec_command_and_print_status "apt-get dist-upgrade -o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef -qq -y --allow-downgrades --allow-remove-essential --allow-change-held-packages" "Upgrade all APT packages" || return $?
    exec_command_and_print_status "apt-get autoclean -y" "Clear APT package cache" || return $?
    exec_command_and_print_status "apt-get autoremove -y" "Remove APT packages that are no long required" || return $?
    which snap >/dev/null
    if [ $? == 0 ]
    then
        exec_command_and_print_status "snap refresh" "Update snap packages"
    fi
    return 0
}

# DESCRIPTION
#     Update Nessus if installed.
# ARGUMENTS
#     None
# RETURN CODE
#     0  - Everything is fine
#     ?  - Return the exit status of the last executed command that failed  
function update_nessus () {
    dir_tools_nessus=$(get_category_path "nessus")
    print_debug "update_nessus" "Nessus diriectory: ${dir_tools_nessus}"
    if [ $? == 0 ]
    then
        if [ -d $dir_tools_nessus ]
        then
            exec_command_and_print_status "service nessusd stop" "Stop Nessus service" || return $?
            exec_command_and_print_status "$dir_tools_nessus/sbin/nessuscli update --all" "Update Nessus core and plugins" || return $?
        fi
    fi
    return 0
}

function install_apt_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    apt_packages=$(echo "$pwnbox_config" | jq -r '.packages.apt[]')
    apt_packages_arg=$(echo $apt_packages)
    export DEBIAN_FRONTEND=noninteractive
    exec_command_and_print_status "apt-get install -o Dpkg::Options::=--force-confold -o Dpkg::Options::=--force-confdef -qq -y --allow-downgrades --allow-remove-essential --allow-change-held-packages ${apt_packages_arg}" "Install additional APT packages" || return $?
    return 0
}

function install_ruby_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    ruby_packages=$(echo "$pwnbox_config" | jq -r '.packages.ruby[]')
    ruby_packages_arg=$(echo $ruby_packages)
    exec_command_and_print_status "gem install ${ruby_packages_arg}" "Install additional ruby gems" || return $?
    return 0
}

function install_python_packages() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    python_packages=$(echo "$pwnbox_config" | jq -r '.packages.python[]')
    python_packages_arg=$(echo $python_packages)
    exec_command_and_print_status "pip3 install ${python_packages_arg}" "Install additional python packages" || return $?
    return 0
}

function download_misc_binaries() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for bin in $(echo "$pwnbox_config" | jq -r '.binaries[] | @base64')
    do
        bin_data=$(echo $bin | base64 -d)
        name=$(echo $bin_data | jq -r '.name')
        print_debug "download_misc_binaries" "Binary name: ${name}"
        url=$(echo $bin_data | jq -r '.url')
        category=$(echo $bin_data | jq -r '.category')
        script=$(echo $bin_data | jq -r '.script')
        directory="$(get_category_path $category)/${name}-bin"
        print_debug "download_misc_binaries" "Download directory: ${directory}"
        if [ ! -d "$directory" ]
        then
            mkdir -p "$directory"
            pushd "$directory" >/dev/null
            exec_command_and_print_status "wget --quiet '${url}'" "Download binary '${name}'"
            if [ $? == 0 ]
            then
                if [ "$script" != "null" ]
                then
                    exec_command "1" "$script"
                fi
            fi
            popd >/dev/null
        fi
    done
}

function download_or_update_git_repositories() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for repo in $(echo "$pwnbox_config" | jq -r '.git_repositories[] | @base64')
    do
        repo_data=$(echo $repo | base64 -d)
        user=$(echo $repo_data | jq -r '.user')
        project=$(echo $repo_data | jq -r '.project')
        category=$(echo $repo_data | jq -r '.category')
        script=$(echo $repo_data | jq -r '.script')
        directory=$(get_category_path $category)
        if [ "$user" != "null" -a "$project" != "null" ]
        then
            url="https://github.com/${user}/${project}"
            if [ ! -d "$directory" ]
            then
                mkdir -p "$directory"
            fi
            if [ -d "$directory/${project}" ]
            then
                # The directory already exists, try to update it
                print_debug "download_or_update_git_repositories" "Target directory '${directory}/${project}' exists"
                pushd "$directory/${project}" >/dev/null
                
                if [ -d "$directory/${project}/.git" ]
                then
                    # It's a GIT repository
                    echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} GIT repository '${user}/${project}'"
                    if [ $(git fetch --dry-run 2>&1 | wc -l) -gt 0 ]
                    then
                        echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} GIT repository '${user}/${project}' needs to be updated"
                        exec_command_and_print_status "git pull --no-rebase" "Update GIT repository '${user}/${project}'"
                    else
                        echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} GIT repository '${user}/${project}'"
                    fi
                else
                    echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLOR_RST} The directory '${directory}/${project}' is not a GIT repository"
                fi

                popd >/dev/null
             else
                # The directory doesn't exist, clone the repository
                print_debug "download_or_update_git_repositories" "Target directory '${directory}/${project}' does not exist"
                pushd "$directory" >/dev/null
                
                exec_command_and_print_status "git clone '${url}' --depth 1" "Clone GIT repository '${user}/${project}'"
                if [ "$script" != "null" ]
                then
                    pushd "$directory/${project}" >/dev/null
                    exec_command_and_print_status "$script" "Run custom install script for repository '${user}/${project}'"
                    popd >/dev/null
                fi
                
                popd >/dev/null
            fi
        fi
    done
}

# DESCRIPTION
#     Validate the content of a release to see if it is properly formatted.
# ARGUMENTS
#     file path - the path of a release file
# RETURN CODE
#     0  - Everything is fine
#     1  - Invalid number of arguments
#     2  - The target file does not exist
#     3  - Did not find the field 'USER'
#     4  - Did not find the field 'PROJECT'
#     5  - Did not find the field 'VERSION'
function validate_release_file() {
    return_code=0
    if [ $# == 1 ]
    then
        if [ -f "$1" ]
        then
            file_content=$(cat "$1")
            echo "$file_content" | grep -q -E "^USER=.+\$" || return 3
            echo "$file_content" | grep -q -E "^PROJECT=.+\$" || return 4
            echo "$file_content" | grep -q -E "^VERSION=.+\$" || return 5
        else
            return_code=2
        fi
    else
        return_code=1
    fi
    return $return_code
}

function download_or_update_git_releases() {
    which jq >/dev/null || return 127
    pwnbox_config=$(cat "$PWNBOX_CONFIG")
    for release in $(echo "$pwnbox_config" | jq -r '.git_releases[] | @base64')
    do
        release_data=$(echo $release | base64 -d)
        release_data_user=$(echo $release_data | jq -r '.user')
        release_data_project=$(echo $release_data | jq -r '.project')
        release_data_archive_password=$(echo $release_data | jq -r '.archive_password')
        release_data_category=$(echo $release_data | jq -r '.category')
        print_debug "download_or_update_git_releases" "Release ${release_data_user}/${release_data_project}"
        
        release_url="https://api.github.com/repos/${release_data_user}/${release_data_project}/releases/latest"
        release_directory="$(get_category_path $release_data_category)/${release_data_project}-bin"
        
        release_git_content=$(curl -L --silent $release_url)
        if [ $? != 0 ]
        then
            echo -e "${COLOR_RED_BOLD}${SIGN_FAIL}${COLR_RST} Failed to get GIT release information for '${release_data_user}/${release_data_project}'"
            continue
        fi
        release_git_version=$(echo "$release_git_content" | jq -r '.tag_name')
        
        # Check if a password is required to decompress the archive(s)
        if [ "$release_data_archive_password" != "" ]
        then
            echo "$release_data_archive_password" | grep -q -E "^UNKNOWN\$"
            if [ $? == 0 ]
            then
                # The value of the password is 'UNKNOWN', which means we don't know it beforehand, so
                # we'll have to extract it from the decsription.
                release_git_body=$(echo "$release_git_content" | jq -r '.body')
                for word in $(echo "$release_git_body")
                do
                    word_nb_chars=$(echo "$word" | wc -c)
                    if [ $word_nb_chars -gt 20 ]
                    then
                        release_data_archive_password=$word
                        print_debug "download_or_update_git_releases" "Found password: ${release_data_archive_password}"
                        break
                    fi
                done
            fi
        fi
        
        to_download=0
        
        if [ -d "$release_directory" ]
        then
            # If the target directory already exists, check if it needs to be updated. If the the 
            # folder is not up to date, remove the contnet and set the 'download' flag to true.
            print_debug "download_or_update_git_releases" "Target directory '${release_directory} exists"
            validate_release_file "${release_directory}/.release"
            if [ $? == 0 ]
            then
                print_debug "download_or_update_git_releases" "Target directory '${release_directory} contains a valid release file"
                release_file_version=$(cat "${release_directory}/.release" | grep -E "^VERSION=" | cut -d'=' -f2)
                echo -ne "${COLOR_CYAN_BOLD}${SIGN_INFO}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}'"
                #release_git_version=$(echo "$release_git_content" | jq -r '.tag_name')
                if [ "$release_git_version" != "" -a "$release_git_version" != "null" ]
                then
                    if [ "$release_git_version" == "$release_file_version" ]
                    then
                        echo -e "\r${COLOR_GREEN_BOLD}${SIGN_PASS}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}' (version: ${release_file_version}) is up to date"
                    else
                        echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLOR_RST} GIT release '${release_data_user}/${release_data_project}' (version: ${release_file_version}) needs to be updated"
                        to_download=1
                    fi
                else
                    echo -e "\r${COLOR_YELLOW_BOLD}${SIGN_WARNING}${COLR_RST} Local version for '${release_data_user}/${release_data_project}' is null or empty"
                fi
            else
                print_debug "download_or_update_git_releases" "Target directory '${release_directory} does not contain a valid release file or it is invalid"
                to_download=1
            fi
            
            if [ $to_download == 1 ]
            then
                pushd "$release_directory" >/dev/null
                print_debug "download_or_update_git_releases" "We will remove everything in $(pwd)"
                rm -rf *
                popd >/dev/null
            fi
        else
            # If the target directory does not exist, create it and set the 'download' flat to true.
            print_debug "download_or_update_git_releases" "Target directory '${release_directory} does not exist"
            mkdir -p "$release_directory"
            if [ $? == 0 ]
            then
                to_download=1
            fi
        fi
        
        if [ $to_download == 1 ]
        then
            print_debug "download_or_update_git_releases" "We should download something"
            # Download the latest release
            
            release_git_urls=$(echo $release_git_content | jq -r '.assets[] | select(.).browser_download_url')
            for release_git_url in $(echo -e $release_git_urls)
            do
                print_debug "download_or_update_git_releases" "Target URL: ${release_git_url}"
                pushd "$release_directory" >/dev/null
                
                arch_name=$(basename $release_git_url)
                if [ "$release_data_archive_password" == "" -o "$release_data_archive_password" == "null" ]
                then
                    exec_command_and_print_status "download_uncompress_archive '${release_git_url}'" "Download and decompress file '${arch_name}'"
                else
                    exec_command_and_print_status "download_uncompress_archive '${release_git_url}' '${release_data_archive_password}'" "Download and decompress file '${arch_name}' (password protected)"
                fi
                
                popd >/dev/null
            done
            
            # Create the .release file
            release_file_content=$(echo "$release_file_content" | sed "s/^VERSION=.*/VERSION=${release_git_version}/g")
            release_file_content=""
            release_file_content="${release_file_content}USER=${release_data_user}"$'\n'
            release_file_content="${release_file_content}PROJECT=${release_data_project}"$'\n'
            release_file_content="${release_file_content}VERSION=${release_git_version}"$'\n'
            pushd "$release_directory" >/dev/null
            echo -e "${release_file_content}" > ".release"
            popd >/dev/null
        fi
    done
}

# ARGUMENTS
#     url - URL of the target file to download
#     password - An optional password to decrypt the archive
# RETURN CODE
#     0  - Everything is fine
#     1  - Failed to download
#     2  - Failed to decompress
function download_uncompress_archive () {
    # Usage:
    #   uncompress_archive <URL>
    return_code=0
    arch_url="$1"
    arch_password=""
    
    if [ $# == 2 -a "$2" != "null" ]
    then
        arch_password="$2"
    fi
    
    filefullname="${1##*/}"
    filename="${filefullname%.*}"
    fileext="${filefullname##*.}"
    
    exec_command "0" "wget --quiet '${arch_url}'"
    if [ $? == 0 ]
    then
        if [ "$fileext" == "zip" ]
        then
            print_debug "download_uncompress_archive" "File '$filefullname' looks like a ZIP archive."
            exec_command "0" "unzip '$filefullname' -d '$filename'" || return 2
            exec_command "0" "rm -f '$filefullname'"
        elif [ "$fileext" == "gz" ]
        then
            print_debug "download_uncompress_archive" "File '$filefullname' looks like a GZIP archive."
            exec_command "0" "gzip -d '$filefullname'" || return 2
        elif [ "$fileext" == "7z" ]
        then
            print_debug "download_uncompress_archive" "File '$filefullname' looks like a 7z archive."
            if [ $arch_password != "" ]
            then
                exec_command "0" "7z x -aou -p'$arch_password' $filefullname" || return 2
            else
                exec_command "0" "7z x -aou '$filefullname'" || return 2
            fi
            exec_command "0" "rm -f '$filefullname'"
        fi
    else
        print_error "download_uncompress_archive" "Failed to download file '${arch_url}'"
        return_code=1
    fi
    
    return $return_code
}

