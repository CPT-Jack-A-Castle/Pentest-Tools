#!/usr/bin/env python3

import argparse

VERBOSE = False

class ComInterface:
    def __init__(self, fc):
        self.raw = fc
        self.comments = self.comment_raw(fc)
        self.guid = None # Guid object 
        self.name = ""
        self.inherit = ""
        self.procedures = [] # Array of Procedure objects 
        self.parse_file()
    def __str__(self):
        res = "GUID: %s\n" % (str(self.guid))
        res += "%s : %s\n" % (self.name, self.inherit)
        for p in self.procedures:
            res += "|__ Procedure: '%s'\n" % p
        return res
    def to_cpp(self):
        res = "%s\n" % (self.comments)
        res += "// GUID IID_%s = %s;\n" % (self.name, self.guid.to_cpp_struct())
        res += "class __declspec(uuid(\"%s\")) " % (str(self.guid))
        res += "%s : public %s {\n" % (self.name, self.inherit)
        res += "public:\n"
        for p in self.procedures:
            res += "\t%s\n" % (p.to_cpp())
        res += "};\n\n"
        res += "_COM_SMARTPTR_TYPEDEF(%s, __uuidof(%s));" % (self.name, self.name)
        return res
    def comment_raw(self, fc):
        res = "// ===== BEGIN PSEUDO CODE GENERATED BY OLEVIEWDOTNET =====\n"
        for l in fc.split('\n'):
            if l != "":
                res += "// %s\n" % (l)
        res += "// ===== END PSEUDO CODE GENERATED BY OLEVIEWDOTNET =====\n"
        return res
    def parse_file(self):
        cnt = 1
        guid_found = False
        name_found = False
        for l in self.raw.split('\n'):  
            if not guid_found and "[Guid(" in l:
                self.guid = parse_guid(l)
                guid_found = True
            if not name_found and "interface " in l:
                name,inherit = parse_interface_name(l)
                self.name = name
                self.inherit = inherit
                name_found = True
            if "HRESULT " in l:
                proc = parse_procedure(l)
                if proc != None:
                    self.procedures.append(proc)
                    if VERBOSE:
                        print("[+] Found procedure '%s'" % proc.name)
            cnt += 1

class Procedure:
    def __init__(self):
        self.ret = ""
        self.name = ""
        self.parameters = [] # Array of Parameter objects 
    def __str__(self):
        return "%s %s(%s)" % (self.ret, self.name, ", ".join([str(o) for o in self.parameters]))
    def to_cpp(self):
        return "virtual %s __stdcall %s(%s) = 0;" % (self.ret, self.name, ", ".join([o.to_cpp() for o in self.parameters]))
        
class Parameter:
    def __init__(self):
        self.inout = ""
        self.type = ""
        self.name = ""
    def __str__(self):
        return "%s %s %s" % (self.inout, self.type, self.name)
    def to_cpp(self):
        return "/*%s*/ %s %s" % (self.inout, self.type, self.name)   

class Guid:
    def __init__(self, guid_str=""):
        self.initialized = False
        self.data1 = 0
        self.data2 = 0
        self.data3 = 0
        self.data4 = []
        if guid_str != "":
            gs = guid_str.split('-') 
            if len(gs) == 5:
                self.initialized = True
                self.data1 = int(gs[0], 16)
                self.data2 = int(gs[1], 16)
                self.data3 = int(gs[2], 16)
                self.data4 = bytes.fromhex("%s%s" % (gs[3], gs[4]))
            else:
                if VERBOSE:
                    print("[-] Failed to create Guid object. Input data was: %s" % guid_str)
    def __str__(self):
        return ("%08X-%04X-%04X-%s-%s" % (self.data1, self.data2, self.data3, "".join(["%02X" % b for b in self.data4[:2]]), "".join(["%02X" % b for b in self.data4[2:]]))).lower()
    def to_cpp_str(self):
        return "{%s}" % str(self)
    def to_cpp_struct(self):
        return ("{ 0x%08X, 0x%04X, 0x%0X, { %s } }" % (self.data1, self.data2, self.data3, ", ".join(hex(b) for b in self.data4))).lower()

def parse_guid(line):
    ls = line.split('"') # e.g.: [Guid("609b9557-4fb6-11d1-9971-00c04fbbb345")]
    if len(ls) != 3:
        print("[-] parse_guid() failed. Input data was: %s" % line)
        return None
    return Guid(ls[1])

def parse_interface_name(line):
    ls = line.split(' ')
    if len(ls) != 5:
        print("[-] parse_interface_name() failed. Input parameter was: %s" % line)
        return "",""
    return ls[1],ls[3]

def sanitize_param_type(t):
    if t == "sbyte[]":
        return "byte*"
    return t

def sanitize_param_name(n):
    if ")" in n:
        return n.split(')')[0]
    return n
    
def strip_comments(line):
    res = ""
    ll = len(line)
    comment = False
    i = 0
    while i < ll:
        if not comment and line[i] == "/": # comment start?
            if (i+1) < ll:
                if line[i+1] == "*":
                    comment = True
                    i += 2
        if comment and line[i] == "*": # comment end?
            if (i+1) < ll:  
                if line[i+1] == "/":
                    comment = False
                    i += 2
        if not comment and i < ll:
            res += line[i]         
        i += 1
    return res
    
def parse_procedure(line):
    res = Procedure()
    param = Parameter()
    
    res.name = "TODO"
    ls = strip_comments(line).split(' ')
    token = "PROC_RET"
    comment = False
    
    for t in ls:
        if t == "":
            continue
        if t == "/*":
            comment = True
            continue
        if t == "*/":
            comment = False
            continue
        if comment:
            continue
        if token == "PROC_RET":
            res.ret = t
            token = "PROC_NAME"
            continue
        if token == "PROC_NAME":
            ts = t.split('(')
            if len(ts) > 1:
                if ts[1] == "/*":
                    comment = True 
            res.name = ts[0]
            token = "PARAM_INOUT"
            continue
        if token == "PARAM_INOUT":
            if "In" in t or "Out" in t:
                param.inout += t
                if "," in t:
                    continue
            else:
                print("[!] Unexpected token: %s" % t)
            token = "PARAM_TYPE"
            continue
        if token == "PARAM_TYPE":
            if "struct" in t:
                param.type = "%s " % t
                continue
            else:
                param.type += sanitize_param_type(t)
                token = "PARAM_NAME"
                continue
        if token == "PARAM_NAME":
            ts = t.split(',')
            param.name = sanitize_param_name(ts[0])
            res.parameters.append(param)
            param = Parameter()
            token = "PARAM_INOUT"
            continue
        print("[!] Unhandled token: %s" % t)
    return res

def main():
    parser = argparse.ArgumentParser(description="OleView2CPP, convert pseudo-code generated by OleViewDotNet to C++")
    parser.add_argument("file", help="File containing pseudo code generated by OleViewDotNet")
    parser.add_argument("-a", "--advanced", action="store_true", help="Advanced mode")
    parser.add_argument("-c", "--clsid", help="Class identifier")
    parser.add_argument("-n", "--name", help="Class name")
    args = parser.parse_args()
    filename = args.file
    
    class_guid = Guid()
    if args.advanced:
        if args.clsid is None:
            print("[-] Advanced mode enabled but the CLSID is missing. Use --clsid")
            return
        class_guid = Guid(args.clsid)
        if not class_guid.initialized:
            print("[-] Invalid Guid: %s" % args.clsid)
            return
        if args.name is None:
            print("[-] Advanced mode enabled but the class name is missing. Use --name")
            return
        print("[*] Advanced mode enabled")
    
    try:
        f = open(filename, 'r')
        fc = f.read()
        f.close()
    except:
        print("[-] Error opening file '%s'" % sys.argv[1])
        return
    
    res = ComInterface(fc)
    print(res.to_cpp())

if __name__ == '__main__':
    main()

